using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace DeclarativeCommandLine.Generator;

[Generator]
public class MyGenerator : IIncrementalGenerator
{
	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		// Step A: filter for type declarations with attributes
		var candidates = context.SyntaxProvider
			.CreateSyntaxProvider(
				predicate: static (s, _) => s is TypeDeclarationSyntax tds && tds.AttributeLists.Count > 0,
				transform: static (ctx, _) => (TypeDeclarationSyntax)ctx.Node)
			.Where(static t => t is not null);

		// Step B: hand candidates + Compilation to a pipeline step
		var combined = context.CompilationProvider.Combine(candidates.Collect());

		// Step C: generate source
		context.RegisterSourceOutput(combined, static (spc, source) =>
		{
			var (compilation, typeDecls) = source;

			var ctx = new DeclContext(compilation);

			var sb = new StringBuilder();

			sb.AppendLine("/// <auto-generated/>");
			sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
			sb.AppendLine("using System;");
			sb.AppendLine("using System.CommandLine;");
			sb.AppendLine("");
			sb.AppendLine("namespace DeclarativeCommandLine.Generated");
			sb.AppendLine("{");
			sb.AppendLine("    public class CommandBuilder");
			sb.AppendLine("    {");
			sb.AppendLine("        public RootCommand Build(IServiceProvider serviceProvider)");
			sb.AppendLine("        {");

			var cmds = typeDecls
				.Select(decl => CommandView.TryParse(ctx, decl, out var view) ? view : null)
				.Where(c => c != null)
				.Select(c => c!)
				.ToList();

			var rootCmds = cmds.Where(c => c.CmdParent == null).ToList();
			if (rootCmds.Count == 0)
			{
				// Diagnostic.Create(); // TODO
			}

			if (rootCmds.Count > 1)
			{
				// Diagnostic.Create(); // TODO
			}

			var rootCmd = rootCmds.FirstOrDefault();

			var cmdIdx = 0;

			WriteCommand(sb, cmds, rootCmd, null, 12);

			var dbg = 2;

			sb.AppendLine($"            return cmd{rootCmd.Index};");
			sb.AppendLine("        }");
			sb.AppendLine("    }");
			sb.AppendLine("}");

			spc.AddSource("CommandBuilder.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
		});
	}

	private static void WriteCommand(StringBuilder sb, List<CommandView> cmds, CommandView cmd, CommandView? parent, int indent)
	{
		var tab = new string(' ', indent);
		var cmdVar = $"cmd{cmd.Index}";

		// sb.AppendLine($"{tab}// {cmd.FullName}");
		if (parent == null)
		{
			// Root command
			sb.AppendLine($"{tab}var {cmdVar} = new RootCommand();");
		}
		else
		{
			// Child command
			sb.AppendLine($"{tab}var {cmdVar} = new Command(\"{cmd.CmdName}\");");
			sb.AppendLine($"{tab}cmd{parent.Index}.Add({cmdVar});");

			foreach (var opt in cmd.Properties)
			{
				var optVar = $"opt{opt.Index}";

				if (opt.ArgumentAttribute != null)
				{
					sb.AppendLine($"{tab}// Argument {opt.OptName}");
					sb.AppendLine($"{tab}var {optVar} = new Argument<{opt.PropertyTypeName}>(\"{opt.OptName}\");");
					sb.AppendLine($"{tab}{{");
					sb.AppendLine($"{tab}    {cmdVar}.Add({optVar});");
					sb.AppendLine($"{tab}    {optVar}.Description = \"{opt.OptDescription}\";");
					sb.AppendLine($"{tab}}}");
				}

				if (opt.OptionAttribute != null)
				{
					sb.AppendLine($"{tab}// Option {opt.OptName}");
					sb.AppendLine($"{tab}var {optVar} = new Option<{opt.PropertyTypeName}>(\"{opt.OptName}\");");
					sb.AppendLine($"{tab}{{");
					sb.AppendLine($"{tab}    {cmdVar}.Add({optVar});");
					sb.AppendLine($"{tab}    {optVar}.Description = \"{opt.OptDescription}\";");
					sb.AppendLine($"{tab}    {optVar}.Hidden = {opt.OptHidden.ToString().ToLowerInvariant()};");
					sb.AppendLine($"{tab}    {optVar}.Required = {opt.OptRequired.ToString().ToLowerInvariant()};");
					sb.AppendLine($"{tab}}}");
				}

			}

			// sb.AppendLine($"{tab}{cmdVar}.Add(cmd{parent.Index});");

			if (cmd.IsExecutable)
			{
				sb.AppendLine(
					$$"""
					{{tab}}{{cmdVar}}.SetAction(async (parseResult, ct) =>
					{{tab}}{
					{{tab}}    Console.WriteLine("Hello Math.Add!");
					{{tab}}
					{{tab}}    var {{cmdVar}}Inst = serviceProvider.GetRequiredService<{{cmd.FullName}}>();
					""");

				foreach (var opt in cmd.Properties)
				{
					var optVar = $"opt{opt.Index}";
					sb.AppendLine($"{tab}    {cmdVar}Inst.{opt.PropertyName} = parseResult.GetValue({optVar});");
				}

				sb.AppendLine();

				sb.AppendLine(
					$$"""
					{{tab}}    if ({{cmdVar}}Inst is IAsyncCommandWithParseResult {{cmdVar}}001)
					{{tab}}    {
					{{tab}}        await {{cmdVar}}001.ExecuteAsync(parseResult, ct).ConfigureAwait(false);
					{{tab}}    }
					{{tab}}
					{{tab}}    if ({{cmdVar}} is IAsyncCommand {{cmdVar}}002)
					{{tab}}    {
					{{tab}}        await {{cmdVar}}002.ExecuteAsync(ct).ConfigureAwait(false);
					{{tab}}    }
					{{tab}}
					{{tab}}    if ({{cmdVar}} is ICommand {{cmdVar}}003)
					{{tab}}    {
					{{tab}}        {{cmdVar}}003.Execute();
					{{tab}}    }
					{{tab}}});

					""");
			}
		}

		var children = cmds.Where(c => c.CmdParent?.EqualsNamedSymbol(cmd.Symbol) ?? false).ToList();
		if (children.Count > 0)
		{
			foreach (var cCmd in children)
			{
				sb.AppendLine($"{tab}// {cCmd.FullName}");
				sb.AppendLine($"{tab}{{");
				WriteCommand(sb, cmds, cCmd, cmd, indent + 4);
				sb.AppendLine($"{tab}}}");
			}
		}
	}

	private static string Indent(int indent) => new(' ', indent);
}